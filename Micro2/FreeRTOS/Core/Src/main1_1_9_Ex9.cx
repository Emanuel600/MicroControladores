#include "init_from_hal.h"

//--------------------------------------------------------------------------------

xTaskHandle xTask2Handle;

void vTask2(void *pvParameters);

//--------------------------------------------------------------------------------
void vTask1(void *pvParameters)
{
	const portTickType  xDelay100ms = 100/portTICK_RATE_MS;
	
	while(1)
	{
		printf("Task 1 is running.\n");
		xTaskCreate(vTask2, "Tarefa 2", 100, NULL, 2, &xTask2Handle);
		vTaskDelay(xDelay100ms);
	}
}
void vTask2(void *pvParameters)
{
	
	while(1)
	{
		printf("Task 2 is running and about to delete itself.\n");
		vTaskDelete(xTask2Handle);
	}
}
//--------------------------------------------------------------------------------
/* A funcao Idle Hook não é uma tarefa, não pode conter um laço infinito,
 * caso contrário, a tarefa Idle não consegue libera os recursos alocado pelo Kernel (tarefas apagadas).
 * A tarefa Idle fica escondida e chama a função Idle Hook se estiver habilitada,
 * A tarefa Idle é responsável por liberar a memória alocada pelo kernel depois de desnecessária.
 * A única memória que é automaticamente liberada é a que não é explicitamente alocada.
 * Caso haja alocação explicita de memória para uma tarefa, esse memória deve ser liberada pelo programador
 * depois que a tarefa for excluida. Alocação dinâmica versus estática.
 */
/*void vApplicationIdleHook()
{
	while(1){};//NAO FAÇA ISSO!!!!
}*/
//--------------------------------------------------------------------------------
int main (void)
{
	HAL_Init();

	SystemClock_Config();

	MX_GPIO_Init();

	MX_USART3_UART_Init();

	//RTOS
	
	xTaskCreate(vTask1,"Tarefa 1",100, NULL, 1, NULL);
	
	vTaskStartScheduler();	// apos este comando o RTOS passa a executar as tarefas

	while (1);
}
//--------------------------------------------------------------------------------
